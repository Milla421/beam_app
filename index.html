<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <title>Shim Stack Analyzer</title>
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            --sidebar-bg: rgba(30, 41, 59, 0.85);
            --card-bg: rgba(30, 41, 59, 0.4);
            --card-border: 1px solid rgba(255, 255, 255, 0.08);
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-glow: 0 0 10px rgba(59, 130, 246, 0.5);
            --input-bg: rgba(0, 0, 0, 0.25);
            --graph-grid: rgba(255, 255, 255, 0.06);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg-gradient);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
            overflow: hidden;
            overscroll-behavior-y: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        /* Sidebar */
        .sidebar {
            width: 370px;
            min-width: 370px;
            background: var(--sidebar-bg);
            backdrop-filter: blur(16px);
            border-right: var(--card-border);
            display: flex;
            flex-direction: column;
            padding: 20px 22px;
            overflow-y: auto;
            z-index: 20;
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.25);
        }

        h1 {
            font-size: 1.35rem;
            margin: 0 0 20px 0;
            color: white;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.5px;
            flex-shrink: 0;
        }

        h1 .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        h2 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin: 20px 0 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 8px;
            flex-shrink: 0;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 14px;
            flex-shrink: 0;
        }

        label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: white;
            padding: 9px 12px;
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 0.85rem;
            font-family: inherit;
            transition: all 0.2s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15);
        }

        /* Slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
            margin: 8px 0;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #334155 0%, #475569 100%);
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent);
            margin-top: -7px;
            box-shadow: var(--accent-glow);
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        /* Shim Items */
        .shim-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1;
            min-height: 80px;
        }

        .shim-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: grid;
            grid-template-columns: 1fr 1fr 30px;
            gap: 10px;
            align-items: end;
            transition: background 0.2s, border-color 0.2s;
            flex-shrink: 0;
        }

        .shim-item:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .shim-item .color-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* Buttons */
        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 9px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: inherit;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-add {
            background: linear-gradient(135deg, #10b981, #059669);
            width: 100%;
            margin-top: 10px;
            flex-shrink: 0;
        }

        .btn-add:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }

        .btn-sm {
            padding: 5px;
            border-radius: 6px;
            height: 34px;
            width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.2);
            box-shadow: none;
        }

        .btn-danger:hover {
            background: #ef4444;
            color: white;
            transform: none;
        }

        /* Workspace */
        .workspace {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .graphs-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .stats-container {
            display: flex;
            gap: 16px;
            flex-shrink: 0;
        }

        .stat-card {
            background: var(--card-bg);
            border: var(--card-border);
            padding: 16px 20px;
            border-radius: 12px;
            flex: 1;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: border-color 0.3s;
        }

        .stat-card:hover {
            border-color: rgba(255, 255, 255, 0.15);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 2px;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .canvas-card {
            background: var(--card-bg);
            border: var(--card-border);
            border-radius: 14px;
            padding: 0;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            position: absolute;
            top: 12px;
            left: 14px;
            z-index: 5;
            background: rgba(15, 23, 42, 0.7);
            padding: 4px 10px;
            border-radius: 6px;
            backdrop-filter: blur(8px);
            font-size: 0.78rem;
            font-weight: 600;
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.05);
            letter-spacing: 0.3px;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            flex: 1;
        }

        #main-view-container {
            height: 380px;
            flex-shrink: 0;
        }

        .graphs-row .canvas-card {
            height: 260px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .value-bubble {
            font-size: 0.85rem;
            color: var(--accent);
            font-weight: 600;
            background: rgba(59, 130, 246, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-variant-numeric: tabular-nums;
        }

        .sidebar-footer {
            margin-top: 16px;
            padding-top: 10px;
            flex-shrink: 0;
        }

        @media (max-width: 1000px) {
            .graphs-row {
                grid-template-columns: 1fr;
            }

            #main-view-container {
                height: 280px;
            }
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
                overflow: auto;
            }

            .sidebar {
                width: 100%;
                min-width: unset;
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .workspace {
                padding: 12px;
            }
        }
    </style>
</head>

<body>

    <!-- Sidebar Controls -->
    <div class="sidebar">
        <h1>
            <div class="logo-icon">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2 20h20" />
                    <path d="M5 20V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v15" />
                </svg>
            </div>
            Shim Stack Analyzer
        </h1>

        <h2>Material & Geometry</h2>
        <div class="control-group">
            <label for="elastic-modulus">Elastic Modulus (GPa)</label>
            <input type="number" id="elastic-modulus" value="200" step="1">
        </div>

        <div class="control-group">
            <label for="shim-width">Width / Diameter (mm)</label>
            <input type="number" id="shim-width" value="20" step="0.5">
        </div>

        <h2>Loading</h2>
        <div class="control-group">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                <label style="margin:0;">Distributed Load (N/mm)</label>
                <span id="force-val" class="value-bubble">2.00 N/mm</span>
            </div>
            <input type="range" id="load-slider" min="0" max="100" value="20" step="1">
            <div style="display: flex; gap: 6px; margin-top: 4px;">
                <input type="number" id="max-load-input" value="10" title="Max Load for Slider" style="flex:1;">
                <span style="align-self: center; font-size: 0.75rem; color:#64748b; font-weight:500;">Max (N/mm)</span>
            </div>
        </div>

        <h2>Shim Stack</h2>
        <div id="shim-list-container" class="shim-list">
            <!-- Shims injected here -->
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-add" id="add-shim-btn">+ Add Shim</button>
            <button class="btn" style="margin-top: 8px; background: #475569; width: 100%;" id="sort-shim-btn">Sort
                (Long → Short)</button>
            <div style="margin-top: 14px; border-top: 1px solid rgba(255,255,255,0.08); padding-top: 12px;">
                <button class="btn" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6);"
                    id="share-btn">Copy Shareable Link</button>
            </div>
        </div>

    </div>

    <!-- Main Visuals -->
    <div class="workspace">

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-value" id="max-deflection">0.000 mm</div>
                <div class="stat-label">Max Tip Deflection</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="max-stress">0.0 MPa</div>
                <div class="stat-label">Max Bending Stress</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="max-moment-val">0.0 N·mm</div>
                <div class="stat-label">Max Bending Moment</div>
            </div>
        </div>

        <div class="canvas-card" id="main-view-container">
            <div class="card-header">Stack Visualization</div>
            <div class="canvas-container">
                <canvas id="main-canvas"></canvas>
            </div>
        </div>

        <div class="graphs-row">
            <div class="canvas-card">
                <div class="card-header">Displacement (mm)</div>
                <div class="canvas-container">
                    <canvas id="disp-canvas"></canvas>
                </div>
            </div>

            <div class="canvas-card">
                <div class="card-header">Bending Moment (N·mm)</div>
                <div class="canvas-container">
                    <canvas id="moment-canvas"></canvas>
                </div>
            </div>
        </div>

        <div class="graphs-row">
            <div class="canvas-card">
                <div class="card-header">Shear Force (N)</div>
                <div class="canvas-container">
                    <canvas id="shear-canvas"></canvas>
                </div>
            </div>
        </div>

    </div>

    <script>
        // ============================================================
        //  CONFIGURATION & STATE
        // ============================================================
        const state = {
            E: 200000, // MPa (N/mm²) — Steel default
            width: 20, // mm
            load: 2.0, // N/mm distributed load
            shims: [
                { length: 40, thickness: 0.25 },
                { length: 35, thickness: 0.20 },
                { length: 30, thickness: 0.20 },
                { length: 25, thickness: 0.15 },
                { length: 20, thickness: 0.15 }
            ]
        };

        // Shim color palette — distinct hues
        const shimColors = [
            { fill: 'hsla(210, 80%, 60%, 0.75)', stroke: 'hsla(210, 80%, 40%, 1)' },
            { fill: 'hsla(190, 75%, 55%, 0.75)', stroke: 'hsla(190, 75%, 35%, 1)' },
            { fill: 'hsla(160, 70%, 50%, 0.75)', stroke: 'hsla(160, 70%, 32%, 1)' },
            { fill: 'hsla(270, 65%, 60%, 0.75)', stroke: 'hsla(270, 65%, 38%, 1)' },
            { fill: 'hsla(35, 80%, 55%, 0.75)', stroke: 'hsla(35, 80%, 35%, 1)' },
            { fill: 'hsla(330, 70%, 58%, 0.75)', stroke: 'hsla(330, 70%, 38%, 1)' },
            { fill: 'hsla(50, 75%, 50%, 0.75)', stroke: 'hsla(50, 75%, 32%, 1)' },
            { fill: 'hsla(140, 65%, 48%, 0.75)', stroke: 'hsla(140, 65%, 30%, 1)' },
        ];

        // ============================================================
        //  DOM ELEMENTS
        // ============================================================
        const els = {
            eMod: document.getElementById('elastic-modulus'),
            width: document.getElementById('shim-width'),
            slider: document.getElementById('load-slider'),
            maxLoadInput: document.getElementById('max-load-input'),
            forceVal: document.getElementById('force-val'),
            shimList: document.getElementById('shim-list-container'),
            addShimBtn: document.getElementById('add-shim-btn'),
            sortShimBtn: document.getElementById('sort-shim-btn'),
            shareBtn: document.getElementById('share-btn'),
            maxDef: document.getElementById('max-deflection'),
            maxStress: document.getElementById('max-stress'),
            maxMoment: document.getElementById('max-moment-val'),
            canvases: {
                main: document.getElementById('main-canvas'),
                disp: document.getElementById('disp-canvas'),
                moment: document.getElementById('moment-canvas'),
                shear: document.getElementById('shear-canvas')
            }
        };

        const ctxs = {
            main: els.canvases.main.getContext('2d'),
            disp: els.canvases.disp.getContext('2d'),
            moment: els.canvases.moment.getContext('2d'),
            shear: els.canvases.shear.getContext('2d')
        };

        // ============================================================
        //  PHYSICS ENGINE — Cantilever Beam with Stacked Unbonded Shims
        //
        //  Model: Fixed at x=0 (wall), free at x=L_max (tip).
        //  Load: Uniform distributed load w (N/mm) acting downward.
        //  Shims: Unbonded (free to slide) → EI = Σ E·(b·t³/12)
        //
        //  Integration uses arc-length parameter s for accuracy
        //  at large deflections (geometrically nonlinear).
        //
        //  Analytical check (single shim, small deflection):
        //    δ_tip = w·L⁴ / (8·E·I)
        //    M_max = w·L² / 2   (at root)
        //    V_max = w·L         (at root)
        //    σ_max = M_max·(t/2) / I
        // ============================================================

        function solvePhysics() {
            let L_max = 0;
            state.shims.forEach(s => L_max = Math.max(L_max, s.length));

            if (L_max === 0 || state.shims.length === 0) return null;

            // --- Discretization ---
            const N = 500;  // Grid points along arc-length
            const ds = L_max / (N - 1);  // Grid ends exactly at L_max

            const S = new Float64Array(N);
            const X = new Float64Array(N);
            const Y = new Float64Array(N);
            const Theta = new Float64Array(N);
            const M = new Float64Array(N);
            const V = new Float64Array(N);
            const EI_arr = new Float64Array(N);

            // --- Compute stiffness at each point ---
            // Unbonded stack: EI_total = Σ E·(b·tᵢ³/12) for all shims covering position s
            for (let i = 0; i < N; i++) {
                const s = i * ds;
                S[i] = s;
                let sumEI = 0;
                for (const shim of state.shims) {
                    if (s <= shim.length) {
                        const Ii = (state.width * Math.pow(shim.thickness, 3)) / 12;
                        sumEI += state.E * Ii;
                    }
                }
                EI_arr[i] = sumEI < 1e-12 ? 1e-12 : sumEI;
            }

            // --- Load integration (backward from tip to root) ---
            // Free end BCs: V(L) = 0, M(L) = 0
            // dV/ds = -w  →  V[i] = V[i+1] + w·ds
            // dM/ds = V   →  M[i] = M[i+1] - V_avg·ds  (trapezoidal)
            V[N - 1] = 0;
            M[N - 1] = 0;

            for (let i = N - 2; i >= 0; i--) {
                const sMid = (S[i] + S[i + 1]) / 2;
                const w = (sMid <= L_max) ? state.load : 0;

                V[i] = V[i + 1] + w * ds;
                // Trapezoidal rule for moment: use average shear
                const V_avg = (V[i] + V[i + 1]) / 2;
                M[i] = M[i + 1] - V_avg * ds;
            }

            // --- Kinematic forward integration (root to tip) ---
            // Fixed end BCs: θ(0) = 0, X(0) = 0, Y(0) = 0
            // dθ/ds = κ = M/EI
            // dX/ds = cos(θ)
            // dY/ds = sin(θ)
            let maxStress = 0;
            let maxMomentMag = 0;

            for (let i = 1; i < N; i++) {
                // Curvature at midpoint (trapezoidal)
                const kappa_prev = M[i - 1] / EI_arr[i - 1];
                const kappa_curr = M[i] / EI_arr[i];
                const kappa_avg = (kappa_prev + kappa_curr) / 2;

                Theta[i] = Theta[i - 1] + kappa_avg * ds;

                const avgTheta = (Theta[i] + Theta[i - 1]) / 2;
                X[i] = X[i - 1] + Math.cos(avgTheta) * ds;
                Y[i] = Y[i - 1] + Math.sin(avgTheta) * ds;

                // Track max moment magnitude
                const momentMag = Math.abs(M[i]);
                if (momentMag > maxMomentMag) maxMomentMag = momentMag;

                // Stress: σ = E·κ·(t/2) for each shim at this position
                if (S[i] <= L_max) {
                    const kappa = Math.abs(kappa_avg);
                    for (const shim of state.shims) {
                        if (S[i] <= shim.length) {
                            const sigma = state.E * kappa * (shim.thickness / 2);
                            if (sigma > maxStress) maxStress = sigma;
                        }
                    }
                }
            }

            // Tip deflection (at the last point = L_max)
            const tipDeflection = Y[N - 1];

            return { S, X, Y, Theta, V, M, maxStress, maxMomentMag, tipDeflection, L_max, N };
        }


        // ============================================================
        //  RENDERING — Main Beam Visualization
        // ============================================================

        function draw() {
            // Solve at current load
            const res = solvePhysics();
            if (!res) return;

            // Solve at max load for stable scaling reference
            const currentLoad = state.load;
            const maxLoadSetting = parseFloat(els.maxLoadInput.value) || 10;
            state.load = maxLoadSetting;
            const resRef = solvePhysics();
            state.load = currentLoad;
            if (!resRef) return;

            // --- Update stat cards ---
            els.maxDef.innerText = Math.abs(res.tipDeflection).toFixed(3) + " mm";
            els.maxStress.innerText = res.maxStress.toFixed(1) + " MPa";
            els.maxStress.style.color = (res.maxStress > 1000) ? "#ef4444" : "white";
            els.forceVal.innerText = state.load.toFixed(2) + " N/mm";
            els.maxMoment.innerText = res.maxMomentMag.toFixed(1) + " N·mm";

            // ---- MAIN CANVAS ----
            const ctx = ctxs.main;
            const W = ctx.canvas._logicalWidth || ctx.canvas.width;
            const H = ctx.canvas._logicalHeight || ctx.canvas.height;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Clip to canvas bounds to prevent any drawing outside
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, W, H);
            ctx.clip();

            // --- Scaling ---
            // Use reference (max load) solution for stable scale
            const padL = 70, padR = 40, padT = 50, padB = 40;
            const availW = W - padL - padR;
            const availH = H - padT - padB;

            // Find bounding box from reference solution
            let refMinY = 0, refMaxY = 0;
            for (let i = 0; i < resRef.N; i++) {
                if (resRef.Y[i] < refMinY) refMinY = resRef.Y[i];
                if (resRef.Y[i] > refMaxY) refMaxY = resRef.Y[i];
            }
            // Include shim thickness in bounding box
            const totalThick = state.shims.reduce((a, s) => a + s.thickness, 0);
            refMaxY = Math.max(refMaxY, totalThick + 1);
            refMinY = Math.min(refMinY, -1);

            const rangeY = Math.max(Math.abs(refMinY), Math.abs(refMaxY)) * 2.2;
            const scaleX = availW / (resRef.L_max * 1.05);
            const scaleY = Math.min(scaleX, availH / rangeY);  // Don't stretch Y beyond available space

            const originX = padL;
            const originY = padT + availH * 0.35;  // Anchor near top third

            // --- Draw subtle grid ---
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 1;
            const gridSpacing = chooseGridSpacing(resRef.L_max);
            for (let g = 0; g <= resRef.L_max; g += gridSpacing) {
                const gx = originX + g * scaleX;
                ctx.beginPath();
                ctx.moveTo(gx, padT);
                ctx.lineTo(gx, H - padB);
                ctx.stroke();
            }

            // --- Draw wall (fixed support) ---
            const wallX = originX;
            const wallTop = padT;
            const wallBot = H - padB;
            const wallW = 8;

            // Solid wall
            ctx.fillStyle = '#475569';
            ctx.fillRect(wallX - wallW, wallTop, wallW, wallBot - wallTop);

            // Hatch marks for fixed support
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1.5;
            const hatchSpacing = 8;
            for (let hy = wallTop; hy < wallBot; hy += hatchSpacing) {
                ctx.beginPath();
                ctx.moveTo(wallX - wallW, hy);
                ctx.lineTo(wallX - wallW - 8, hy + 8);
                ctx.stroke();
            }

            // --- Clip beam drawing to the right of the wall ---
            // This prevents the beam from rendering past the y-axis (wall)
            ctx.save();
            ctx.beginPath();
            ctx.rect(originX, 0, W - originX, H);
            ctx.clip();

            // --- Pre-calculate screen points from actual solution ---
            const screenPts = [];
            for (let i = 0; i < res.N; i++) {
                screenPts.push({
                    x: originX + res.X[i] * scaleX,
                    y: originY - res.Y[i] * scaleY  // Invert Y for screen coords
                });
            }

            // --- Compute normals for thickness offset ---
            const normals = [];
            for (let i = 0; i < screenPts.length; i++) {
                let dx, dy;
                if (i === 0) {
                    dx = screenPts[1].x - screenPts[0].x;
                    dy = screenPts[1].y - screenPts[0].y;
                } else if (i === screenPts.length - 1) {
                    dx = screenPts[i].x - screenPts[i - 1].x;
                    dy = screenPts[i].y - screenPts[i - 1].y;
                } else {
                    dx = screenPts[i + 1].x - screenPts[i - 1].x;
                    dy = screenPts[i + 1].y - screenPts[i - 1].y;
                }
                const len = Math.hypot(dx, dy);
                if (len < 1e-9) normals.push({ x: 0, y: -1 });
                else normals.push({ x: dy / len, y: -dx / len });
            }

            // --- Draw load arrows ---
            if (state.load > 0) {
                const arrowCount = Math.min(20, Math.max(5, Math.floor(resRef.L_max / 3)));
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.lineWidth = 1.5;

                for (let a = 0; a < arrowCount; a++) {
                    const frac = (a + 0.5) / arrowCount;
                    const idx = Math.floor(frac * (res.N - 1));
                    const px = screenPts[idx].x;
                    const py = screenPts[idx].y;
                    const arrowLen = 22;
                    const tipSize = 4;

                    // Arrow shaft (from above the beam, pointing down to beam)
                    const topOffset = totalThick * scaleY + 8;
                    const startY = py - topOffset - arrowLen;
                    const endY = py - topOffset;

                    ctx.beginPath();
                    ctx.moveTo(px, startY);
                    ctx.lineTo(px, endY);
                    ctx.stroke();

                    // Arrowhead
                    ctx.beginPath();
                    ctx.moveTo(px, endY + 2);
                    ctx.lineTo(px - tipSize, endY - tipSize);
                    ctx.lineTo(px + tipSize, endY - tipSize);
                    ctx.closePath();
                    ctx.fill();
                }

                // Load label
                ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                ctx.font = '600 11px Inter, sans-serif';
                ctx.textAlign = 'center';
                const midIdx = Math.floor(res.N / 2);
                const topY = screenPts[midIdx].y - totalThick * scaleY - 38;
                ctx.fillText(`w = ${state.load.toFixed(2)} N/mm`, screenPts[midIdx].x, topY);
                ctx.textAlign = 'left';
            }

            // --- Draw shims ---
            let thickOffset = 0;

            state.shims.forEach((shim, idx) => {
                const t = shim.thickness;
                const col = shimColors[idx % shimColors.length];

                ctx.fillStyle = col.fill;
                ctx.strokeStyle = col.stroke;
                ctx.lineWidth = 1.2;
                ctx.beginPath();

                // Top edge (offset = thickOffset + t)
                let lastIdx = 0;
                for (let i = 0; i < res.N; i++) {
                    if (res.S[i] > shim.length) break;
                    lastIdx = i;

                    const offset = (thickOffset + t) * scaleY;
                    const px = screenPts[i].x + normals[i].x * offset;
                    const py = screenPts[i].y + normals[i].y * offset;

                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }

                // Bottom edge (offset = thickOffset) — traverse backward
                for (let i = lastIdx; i >= 0; i--) {
                    const offset = thickOffset * scaleY;
                    const px = screenPts[i].x + normals[i].x * offset;
                    const py = screenPts[i].y + normals[i].y * offset;
                    ctx.lineTo(px, py);
                }

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                thickOffset += t;
            });

            // --- Draw neutral axis (centerline) ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            for (let i = 0; i < res.N; i++) {
                if (i === 0) ctx.moveTo(screenPts[i].x, screenPts[i].y);
                else ctx.lineTo(screenPts[i].x, screenPts[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // --- Dimension annotation ---
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.font = '500 10px Inter, sans-serif';
            ctx.fillText(`L_max = ${resRef.L_max.toFixed(1)} mm`, originX + 4, H - 12);

            // Tip deflection annotation
            if (Math.abs(res.tipDeflection) > 0.001) {
                const tipPt = screenPts[screenPts.length - 1];
                ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                ctx.font = '600 11px Inter, sans-serif';
                ctx.fillText(`δ = ${Math.abs(res.tipDeflection).toFixed(3)} mm`,
                    tipPt.x + 8, tipPt.y + 4);

                // Deflection indicator line
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(tipPt.x, originY);
                ctx.lineTo(tipPt.x, tipPt.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Restore beam clipping (right of wall)
            ctx.restore();
            // Restore canvas bounds clipping
            ctx.restore();

            // --- Auxiliary Graphs ---
            drawGraph(ctxs.disp, res.X, res.Y, "Deflection", "#3b82f6", "x (mm)", "y (mm)");
            drawGraph(ctxs.moment, res.S, res.M, "Moment", "#10b981", "s (mm)", "M (N·mm)");
            drawGraph(ctxs.shear, res.S, res.V, "Shear", "#f59e0b", "s (mm)", "V (N)");
        }


        // ============================================================
        //  AUXILIARY GRAPH RENDERER
        // ============================================================

        function drawGraph(ctx, X, Y, label, color, xLabel, yLabel) {
            const W = ctx.canvas._logicalWidth || ctx.canvas.width;
            const H = ctx.canvas._logicalHeight || ctx.canvas.height;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            const padL = 55, padR = 15, padT = 30, padB = 30;
            const plotW = W - padL - padR;
            const plotH = H - padT - padB;

            if (plotW <= 0 || plotH <= 0) return;

            const minX = 0, maxX = X[X.length - 1] || 1;
            let minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < Y.length; i++) {
                if (Y[i] < minY) minY = Y[i];
                if (Y[i] > maxY) maxY = Y[i];
            }

            // Expand range to include zero
            if (minY > 0) minY = 0;
            if (maxY < 0) maxY = 0;

            // Add 10% padding
            let rY = maxY - minY;
            if (rY < 1e-9) { maxY += 1; minY -= 1; rY = 2; }
            minY -= rY * 0.08;
            maxY += rY * 0.08;
            rY = maxY - minY;

            const rX = maxX - minX || 1;

            const mapX = v => padL + ((v - minX) / rX) * plotW;
            const mapY = v => (padT + plotH) - ((v - minY) / rY) * plotH;

            // --- Grid lines ---
            ctx.font = '500 9px Inter, sans-serif';

            // Y-axis grid
            const yTicks = niceTicksRange(minY, maxY, 5);
            ctx.textAlign = 'right';
            for (const yv of yTicks) {
                const py = mapY(yv);
                if (py < padT - 2 || py > padT + plotH + 2) continue;

                ctx.strokeStyle = (Math.abs(yv) < rY * 0.001) ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.05)';
                ctx.lineWidth = (Math.abs(yv) < rY * 0.001) ? 1.2 : 0.8;
                ctx.beginPath();
                ctx.moveTo(padL, py);
                ctx.lineTo(W - padR, py);
                ctx.stroke();

                ctx.fillStyle = '#64748b';
                ctx.fillText(formatEngineering(yv), padL - 5, py + 3);
            }

            // X-axis grid
            const xTicks = niceTicksRange(minX, maxX, 5);
            ctx.textAlign = 'center';
            for (const xv of xTicks) {
                const px = mapX(xv);
                if (px < padL - 2 || px > W - padR + 2) continue;

                ctx.strokeStyle = 'rgba(255,255,255,0.04)';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(px, padT);
                ctx.lineTo(px, padT + plotH);
                ctx.stroke();

                ctx.fillStyle = '#64748b';
                ctx.fillText(formatEngineering(xv), px, padT + plotH + 14);
            }

            // --- Area fill under curve ---
            const zeroY = mapY(0);
            ctx.fillStyle = color.replace(')', ', 0.08)').replace('rgb', 'rgba');
            // Parse hex color for area fill
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r},${g},${b}, 0.08)`;
            ctx.beginPath();
            ctx.moveTo(mapX(X[0]), zeroY);
            for (let i = 0; i < X.length; i++) {
                ctx.lineTo(mapX(X[i]), mapY(Y[i]));
            }
            ctx.lineTo(mapX(X[X.length - 1]), zeroY);
            ctx.closePath();
            ctx.fill();

            // --- Data line ---
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            for (let i = 0; i < X.length; i++) {
                const px = mapX(X[i]);
                const py = mapY(Y[i]);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // --- Max/min annotation ---
            let absMax = 0, absMaxIdx = 0;
            for (let i = 0; i < Y.length; i++) {
                if (Math.abs(Y[i]) > absMax) { absMax = Math.abs(Y[i]); absMaxIdx = i; }
            }
            if (absMax > 1e-6) {
                const annotX = mapX(X[absMaxIdx]);
                const annotY = mapY(Y[absMaxIdx]);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(annotX, annotY, 3.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '600 9px Inter, sans-serif';
                ctx.textAlign = annotX > W / 2 ? 'right' : 'left';
                const offsetDir = annotX > W / 2 ? -8 : 8;
                ctx.fillText(formatEngineering(Y[absMaxIdx]), annotX + offsetDir, annotY - 8);
            }

            // --- Axis labels ---
            ctx.fillStyle = '#64748b';
            ctx.font = '500 9px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(xLabel, padL + plotW / 2, H - 4);
            // Y label (rotated)
            ctx.save();
            ctx.translate(11, padT + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();

            // --- Plot border ---
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            ctx.strokeRect(padL, padT, plotW, plotH);
        }


        // ============================================================
        //  UTILITY FUNCTIONS
        // ============================================================

        /** Choose grid spacing that gives ~5-10 lines */
        function chooseGridSpacing(maxVal) {
            const rough = maxVal / 8;
            const mag = Math.pow(10, Math.floor(Math.log10(rough)));
            const steps = [1, 2, 5, 10];
            for (const s of steps) {
                if (s * mag >= rough) return s * mag;
            }
            return mag * 10;
        }

        /** Generate nice tick values for axis labels */
        function niceTicksRange(min, max, targetCount) {
            const range = max - min;
            if (range <= 0) return [0];

            const roughStep = range / targetCount;
            const mag = Math.pow(10, Math.floor(Math.log10(roughStep)));
            const candidates = [1, 2, 5, 10];
            let step = mag;
            for (const c of candidates) {
                if (c * mag >= roughStep) { step = c * mag; break; }
            }

            // Round to step precision to avoid floating-point drift
            const decimals = Math.max(0, -Math.floor(Math.log10(step)) + 1);
            const ticks = [];
            const start = Math.ceil(min / step) * step;
            for (let v = start; v <= max + step * 0.01; v += step) {
                ticks.push(parseFloat(v.toFixed(decimals)));
            }
            return ticks;
        }

        /** Format numbers with engineering precision */
        function formatEngineering(v) {
            if (Math.abs(v) < 1e-9) return '0';
            const abs = Math.abs(v);
            if (abs >= 1000) return v.toFixed(0);
            if (abs >= 100) return v.toFixed(0);
            if (abs >= 10) return v.toFixed(1);
            if (abs >= 1) return v.toFixed(2);
            if (abs >= 0.1) return v.toFixed(3);
            return v.toPrecision(3);
        }


        // ============================================================
        //  STATE MANAGEMENT & UI
        // ============================================================

        function updateState() {
            state.E = parseFloat(els.eMod.value) * 1000;  // GPa → MPa
            state.width = parseFloat(els.width.value) || 20;
            const maxL = parseFloat(els.maxLoadInput.value) || 10;
            const pct = parseFloat(els.slider.value);
            state.load = (pct / 100) * maxL;
            draw();
        }

        function renderShimList() {
            els.shimList.innerHTML = '';
            state.shims.forEach((shim, idx) => {
                const col = shimColors[idx % shimColors.length];
                const item = document.createElement('div');
                item.className = 'shim-item';
                item.innerHTML = `
                    <div>
                        <label><span class="color-dot" style="background:${col.fill.replace('0.75', '1')}"></span>Length (mm)</label>
                        <input type="number" value="${shim.length}" step="1"
                            onchange="updateShim(${idx}, 'length', this.value)">
                    </div>
                    <div>
                        <label>Thickness (mm)</label>
                        <input type="number" value="${shim.thickness}" step="0.05"
                            onchange="updateShim(${idx}, 'thickness', this.value)">
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeShim(${idx})">✕</button>
                `;
                els.shimList.appendChild(item);
            });
        }

        window.updateShim = (i, k, v) => { state.shims[i][k] = parseFloat(v); updateState(); };
        window.removeShim = (i) => { state.shims.splice(i, 1); renderShimList(); updateState(); };

        els.eMod.oninput = updateState;
        els.width.oninput = updateState;
        els.maxLoadInput.onchange = updateState;
        els.slider.oninput = updateState;
        els.addShimBtn.onclick = () => {
            state.shims.push({ length: 30, thickness: 0.2 });
            renderShimList();
            updateState();
        };
        els.sortShimBtn.onclick = () => {
            state.shims.sort((a, b) => b.length - a.length);
            renderShimList();
            updateState();
        };


        // ============================================================
        //  SHARING
        // ============================================================

        els.shareBtn.onclick = () => {
            const data = {
                s: state.shims, ps: { E: state.E, w: state.width, mx: els.maxLoadInput.value }
            };
            const b64 = btoa(JSON.stringify(data));
            const url = window.location.href.split('#')[0] + '#' + b64;
            navigator.clipboard.writeText(url).then(() => {
                const old = els.shareBtn.innerText;
                els.shareBtn.innerText = "✓ Copied!";
                setTimeout(() => els.shareBtn.innerText = old, 1500);
            });
        };

        function loadFromUrl() {
            if (window.location.hash) {
                try {
                    const data = JSON.parse(atob(window.location.hash.substring(1)));
                    if (data.s) state.shims = data.s;
                    if (data.ps) {
                        state.E = parseFloat(data.ps.E);
                        state.width = parseFloat(data.ps.w);
                        els.maxLoadInput.value = data.ps.mx;
                    }
                    els.eMod.value = state.E / 1000;
                    els.width.value = state.width;
                    renderShimList();
                } catch (e) { console.log(e); }
            }
        }


        // ============================================================
        //  INITIALIZATION
        // ============================================================

        function resizeCanvases() {
            Object.values(els.canvases).forEach(c => {
                const r = c.parentElement.getBoundingClientRect();
                // Use devicePixelRatio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                c.width = r.width * dpr;
                c.height = r.height * dpr;
                c.style.width = r.width + 'px';
                c.style.height = r.height + 'px';
                c.getContext('2d').scale(dpr, dpr);
                // Store logical size for drawing
                c._logicalWidth = r.width;
                c._logicalHeight = r.height;
            });
            draw();
        }

        // Override canvas width/height getters for logical coordinates
        const origCtxGetter = Object.getOwnPropertyDescriptor(HTMLCanvasElement.prototype, 'width');

        // Patch draw functions to use logical dimensions
        const origGetContext = HTMLCanvasElement.prototype.getContext;

        window.onresize = resizeCanvases;

        loadFromUrl();
        renderShimList();
        setTimeout(resizeCanvases, 100);
    </script>
</body>

</html>