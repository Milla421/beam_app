<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <!-- PWA Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f172a">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <title>Shim Stack Analyzer</title>
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            --sidebar-bg: rgba(30, 41, 59, 0.85);
            --card-bg: rgba(30, 41, 59, 0.4);
            --card-border: 1px solid rgba(255, 255, 255, 0.08);
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --accent: #3b82f6;
            --accent-glow: 0 0 10px rgba(59, 130, 246, 0.5);
            --input-bg: rgba(0, 0, 0, 0.25);
            --graph-grid: rgba(255, 255, 255, 0.06);
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg-gradient);
            color: var(--text-primary);
            display: flex;
            height: 100vh;
            overflow: hidden;
            overscroll-behavior-y: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        /* Sidebar */
        .sidebar {
            width: 370px;
            min-width: 370px;
            background: var(--sidebar-bg);
            backdrop-filter: blur(16px);
            border-right: var(--card-border);
            display: flex;
            flex-direction: column;
            padding: 20px 22px;
            overflow-y: auto;
            z-index: 20;
            box-shadow: 5px 0 30px rgba(0, 0, 0, 0.25);
        }

        h1 {
            font-size: 1.35rem;
            margin: 0 0 20px 0;
            color: white;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.5px;
            flex-shrink: 0;
        }

        h1 .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        h2 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin: 20px 0 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 8px;
            flex-shrink: 0;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 14px;
            flex-shrink: 0;
        }

        label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="number"],
        input[type="text"] {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: white;
            padding: 9px 12px;
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 0.85rem;
            font-family: inherit;
            transition: all 0.2s;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent);
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15);
        }

        /* Slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
            margin: 8px 0;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, #334155 0%, #475569 100%);
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent);
            margin-top: -7px;
            box-shadow: var(--accent-glow);
            cursor: pointer;
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        /* Shim Items */
        .shim-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .shim-item {
            background: rgba(255, 255, 255, 0.03);
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: grid;
            grid-template-columns: 1fr 1fr 30px;
            gap: 10px;
            align-items: end;
            transition: background 0.2s, border-color 0.2s;
            flex-shrink: 0;
        }

        .shim-item:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .shim-item .color-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* Buttons */
        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 9px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: inherit;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-add {
            background: linear-gradient(135deg, #10b981, #059669);
            width: 100%;
            margin-top: 10px;
            flex-shrink: 0;
        }

        .btn-add:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }

        .btn-sm {
            padding: 5px;
            border-radius: 6px;
            height: 34px;
            width: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .btn-danger {
            background: rgba(239, 68, 68, 0.15);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.2);
            box-shadow: none;
        }

        .btn-danger:hover {
            background: #ef4444;
            color: white;
            transform: none;
        }

        /* Workspace */
        .workspace {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .graphs-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .stats-container {
            display: flex;
            gap: 16px;
            flex-shrink: 0;
        }

        .stat-card {
            background: var(--card-bg);
            border: var(--card-border);
            padding: 16px 20px;
            border-radius: 12px;
            flex: 1;
            text-align: center;
            backdrop-filter: blur(5px);
            transition: border-color 0.3s;
        }

        .stat-card:hover {
            border-color: rgba(255, 255, 255, 0.15);
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
            margin-bottom: 2px;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .canvas-card {
            background: var(--card-bg);
            border: var(--card-border);
            border-radius: 14px;
            padding: 0;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .card-header {
            position: absolute;
            top: 12px;
            left: 14px;
            z-index: 5;
            background: rgba(15, 23, 42, 0.7);
            padding: 4px 10px;
            border-radius: 6px;
            backdrop-filter: blur(8px);
            font-size: 0.78rem;
            font-weight: 600;
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.05);
            letter-spacing: 0.3px;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            flex: 1;
        }

        #main-view-container {
            height: 380px;
            flex-shrink: 0;
        }

        .graphs-row .canvas-card {
            height: 260px;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .value-bubble {
            font-size: 0.85rem;
            color: var(--accent);
            font-weight: 600;
            background: rgba(59, 130, 246, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            font-variant-numeric: tabular-nums;
        }

        .sidebar-footer {
            margin-top: 16px;
            padding-top: 10px;
            flex-shrink: 0;
        }

        /* Math Equations Panel */
        .math-panel {
            background: var(--card-bg);
            border: var(--card-border);
            border-radius: 14px;
            padding: 20px 24px;
            flex-shrink: 0;
        }

        .math-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .math-panel-header h3 {
            margin: 0;
            font-size: 1rem;
            color: white;
            font-weight: 700;
        }

        .math-section {
            margin-bottom: 18px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .math-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .math-section-title {
            font-size: 0.78rem;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .math-formula {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 10px 14px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #e2e8f0;
        }

        .math-formula .formula-label {
            color: #94a3b8;
            font-family: 'Inter', sans-serif;
            font-size: 0.72rem;
            font-weight: 500;
            margin-bottom: 4px;
            display: block;
        }

        .math-formula .formula-eq {
            color: #f8fafc;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .math-formula .formula-result {
            color: #22d3ee;
            font-weight: 700;
            margin-top: 4px;
            display: block;
        }

        .math-shim-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
            margin-top: 6px;
        }

        .math-shim-table th {
            text-align: left;
            padding: 6px 10px;
            color: #94a3b8;
            font-weight: 600;
            font-size: 0.72rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .math-shim-table td {
            padding: 5px 10px;
            color: #e2e8f0;
            font-family: 'Courier New', monospace;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .math-shim-table tr:last-child td {
            border-bottom: none;
        }

        .math-shim-table .total-row td {
            color: #22d3ee;
            font-weight: 700;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 8px;
        }

        @media (max-width: 1000px) {
            .graphs-row {
                grid-template-columns: 1fr;
            }

            #main-view-container {
                height: 280px;
            }
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
                overflow: auto;
            }

            .sidebar {
                width: 100%;
                min-width: unset;
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .workspace {
                padding: 12px;
            }
        }
    </style>
</head>

<body>

    <!-- Sidebar Controls -->
    <div class="sidebar">
        <h1>
            <div class="logo-icon">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2 20h20" />
                    <path d="M5 20V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v15" />
                </svg>
            </div>
            Shim Stack Analyzer
        </h1>

        <h2>Material & Geometry</h2>
        <div class="control-group">
            <label for="elastic-modulus">Elastic Modulus (GPa)</label>
            <input type="number" id="elastic-modulus" value="200" step="1" min="0">
        </div>

        <div class="control-group">
            <label for="shim-width">Width / Diameter (mm)</label>
            <input type="number" id="shim-width" value="20" step="0.5" min="0.1">
        </div>

        <h2>Loading</h2>
        <div class="control-group">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                <label style="margin:0;">Distributed Load (N/mm)</label>
                <span id="force-val" class="value-bubble">2.00 N/mm</span>
            </div>
            <input type="range" id="load-slider" min="0" max="100" value="0" step="1">
            <div style="display: flex; gap: 6px; margin-top: 4px;">
                <input type="number" id="max-load-input" value="10" title="Max Load for Slider" style="flex:1;" min="0">
                <span style="align-self: center; font-size: 0.75rem; color:#64748b; font-weight:500;">Max (N/mm)</span>
            </div>
        </div>

        <h2>Shim Stack</h2>
        <div id="shim-list-container" class="shim-list">
            <!-- Shims injected here -->
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-add" id="add-shim-btn">+ Add Shim</button>
            <button class="btn" style="margin-top: 8px; background: #475569; width: 100%;" id="sort-shim-btn">Sort
                (Long ‚Üí Short)</button>
            <div style="margin-top: 14px; border-top: 1px solid rgba(255,255,255,0.08); padding-top: 12px;">
                <button class="btn" style="width: 100%; background: linear-gradient(135deg, #6366f1, #8b5cf6);"
                    id="share-btn">Copy Shareable Link</button>
            </div>
        </div>

    </div>

    <!-- Main Visuals -->
    <div class="workspace">

        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-value" id="max-deflection">0.000 mm</div>
                <div class="stat-label">Max Tip Deflection</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="max-stress">0.0 MPa</div>
                <div class="stat-label">Max Bending Stress</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="max-moment-val">0.0 N¬∑mm</div>
                <div class="stat-label">Max Bending Moment</div>
            </div>
        </div>

        <div class="canvas-card" id="main-view-container">
            <div class="card-header">Stack Visualization</div>
            <div class="canvas-container">
                <canvas id="main-canvas"></canvas>
            </div>
        </div>

        <div class="graphs-row">
            <div class="canvas-card">
                <div class="card-header">Displacement (mm)</div>
                <div class="canvas-container">
                    <canvas id="disp-canvas"></canvas>
                </div>
            </div>

            <div class="canvas-card">
                <div class="card-header">Bending Moment (N¬∑mm)</div>
                <div class="canvas-container">
                    <canvas id="moment-canvas"></canvas>
                </div>
            </div>
        </div>

        <div class="graphs-row">
            <div class="canvas-card">
                <div class="card-header">Shear Force (N)</div>
                <div class="canvas-container">
                    <canvas id="shear-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Live Math Equations Panel -->
        <div class="math-panel" id="math-panel">
            <div class="math-panel-header">
                <h3>üìê Live Calculation Sheet</h3>
                <button class="btn btn-sm" id="toggle-math-btn"
                    style="background:rgba(255,255,255,0.1);color:#94a3b8;border:1px solid rgba(255,255,255,0.1);width:auto;padding:4px 10px;font-size:0.75rem;">Collapse</button>
            </div>
            <div id="math-content">
                <!-- Populated by JS -->
            </div>
        </div>

    </div>

    <script>
        // ============================================================
        //  CONFIGURATION & STATE
        // ============================================================
        const state = {
            E: 200000, // MPa (N/mm¬≤) ‚Äî Steel default
            width: 20, // mm
            load: 0, // N/mm distributed load
            shims: [
                { length: 40, thickness: 0.5 },
                { length: 35, thickness: 0.5 },
                { length: 30, thickness: 0.5 },
                { length: 25, thickness: 0.5 },
                { length: 20, thickness: 0.5 }
            ]
        };

        // Shim color palette ‚Äî maximally distinct hues across full spectrum
        const shimColors = [
            { fill: 'hsla(0, 85%, 60%, 0.80)', stroke: 'hsla(0, 85%, 40%, 1)' },    // Red
            { fill: 'hsla(210, 90%, 55%, 0.80)', stroke: 'hsla(210, 90%, 35%, 1)' },   // Blue
            { fill: 'hsla(120, 70%, 45%, 0.80)', stroke: 'hsla(120, 70%, 28%, 1)' },   // Green
            { fill: 'hsla(45, 95%, 55%, 0.80)', stroke: 'hsla(45, 95%, 35%, 1)' },    // Amber
            { fill: 'hsla(280, 75%, 60%, 0.80)', stroke: 'hsla(280, 75%, 38%, 1)' },   // Purple
            { fill: 'hsla(175, 80%, 45%, 0.80)', stroke: 'hsla(175, 80%, 28%, 1)' },   // Teal
            { fill: 'hsla(340, 85%, 58%, 0.80)', stroke: 'hsla(340, 85%, 38%, 1)' },   // Pink
            { fill: 'hsla(80, 75%, 48%, 0.80)', stroke: 'hsla(80, 75%, 30%, 1)' },    // Lime
        ];

        // ============================================================
        //  DOM ELEMENTS
        // ============================================================
        const els = {
            eMod: document.getElementById('elastic-modulus'),
            width: document.getElementById('shim-width'),
            slider: document.getElementById('load-slider'),
            maxLoadInput: document.getElementById('max-load-input'),
            forceVal: document.getElementById('force-val'),
            shimList: document.getElementById('shim-list-container'),
            addShimBtn: document.getElementById('add-shim-btn'),
            sortShimBtn: document.getElementById('sort-shim-btn'),
            shareBtn: document.getElementById('share-btn'),
            maxDef: document.getElementById('max-deflection'),
            maxStress: document.getElementById('max-stress'),
            maxMoment: document.getElementById('max-moment-val'),
            canvases: {
                main: document.getElementById('main-canvas'),
                disp: document.getElementById('disp-canvas'),
                moment: document.getElementById('moment-canvas'),
                shear: document.getElementById('shear-canvas')
            }
        };

        const ctxs = {
            main: els.canvases.main.getContext('2d'),
            disp: els.canvases.disp.getContext('2d'),
            moment: els.canvases.moment.getContext('2d'),
            shear: els.canvases.shear.getContext('2d')
        };

        // ============================================================
        //  PHYSICS ENGINE ‚Äî Cantilever Beam with Stacked Unbonded Shims
        //
        //  Model: Fixed at x=0 (wall), free at x=L_max (tip).
        //  Load: Uniform distributed load w (N/mm) acting downward.
        //  Shims: Unbonded (free to slide) ‚Üí EI = Œ£ E¬∑(b¬∑t¬≥/12)
        //
        //  Integration uses arc-length parameter s for accuracy
        //  at large deflections (geometrically nonlinear).
        //
        //  Analytical check (single shim, small deflection):
        //    Œ¥_tip = w¬∑L‚Å¥ / (8¬∑E¬∑I)
        //    M_max = w¬∑L¬≤ / 2   (at root)
        //    V_max = w¬∑L         (at root)
        //    œÉ_max = M_max¬∑(t/2) / I
        // ============================================================

        function solvePhysics() {
            let L_max = 0;
            state.shims.forEach(s => L_max = Math.max(L_max, s.length));

            if (L_max === 0 || state.shims.length === 0) return null;

            // --- Discretization ---
            const N = 500;  // Grid points along arc-length
            const ds = L_max / (N - 1);  // Grid ends exactly at L_max

            const S = new Float64Array(N);
            const X = new Float64Array(N);
            const Y = new Float64Array(N);
            const Theta = new Float64Array(N);
            const M = new Float64Array(N);
            const V = new Float64Array(N);
            const EI_arr = new Float64Array(N);

            // --- Compute stiffness at each point ---
            // Unbonded stack: EI_total = Œ£ E¬∑(b¬∑t·µ¢¬≥/12) for all shims covering position s
            for (let i = 0; i < N; i++) {
                const s = i * ds;
                S[i] = s;
                let sumEI = 0;
                for (const shim of state.shims) {
                    if (s <= shim.length) {
                        const Ii = (state.width * Math.pow(shim.thickness, 3)) / 12;
                        sumEI += state.E * Ii;
                    }
                }
                EI_arr[i] = sumEI < 1e-12 ? 1e-12 : sumEI;
            }

            // --- Load integration (backward from tip to root) ---
            // Free end BCs: V(L) = 0, M(L) = 0
            // dV/ds = -w  ‚Üí  V[i] = V[i+1] + w¬∑ds
            // dM/ds = V   ‚Üí  M[i] = M[i+1] - V_avg¬∑ds  (trapezoidal)
            V[N - 1] = 0;
            M[N - 1] = 0;

            for (let i = N - 2; i >= 0; i--) {
                const sMid = (S[i] + S[i + 1]) / 2;
                const w = (sMid <= L_max) ? state.load : 0;

                V[i] = V[i + 1] + w * ds;
                // Trapezoidal rule for moment: use average shear
                const V_avg = (V[i] + V[i + 1]) / 2;
                M[i] = M[i + 1] - V_avg * ds;
            }

            // --- Kinematic forward integration (root to tip) ---
            // Fixed end BCs: Œ∏(0) = 0, X(0) = 0, Y(0) = 0
            // dŒ∏/ds = Œ∫ = M/EI
            // dX/ds = cos(Œ∏)
            // dY/ds = sin(Œ∏)
            let maxStress = 0;
            let maxMomentMag = 0;

            for (let i = 1; i < N; i++) {
                // Curvature at midpoint (trapezoidal)
                const kappa_prev = M[i - 1] / EI_arr[i - 1];
                const kappa_curr = M[i] / EI_arr[i];
                const kappa_avg = (kappa_prev + kappa_curr) / 2;

                Theta[i] = Theta[i - 1] + kappa_avg * ds;

                const avgTheta = (Theta[i] + Theta[i - 1]) / 2;
                X[i] = X[i - 1] + Math.cos(avgTheta) * ds;
                Y[i] = Y[i - 1] + Math.sin(avgTheta) * ds;

                // Track max moment magnitude
                const momentMag = Math.abs(M[i]);
                if (momentMag > maxMomentMag) maxMomentMag = momentMag;

                // Stress: œÉ = E¬∑Œ∫¬∑(t/2) for each shim at this position
                if (S[i] <= L_max) {
                    const kappa = Math.abs(kappa_avg);
                    for (const shim of state.shims) {
                        if (S[i] <= shim.length) {
                            const sigma = state.E * kappa * (shim.thickness / 2);
                            if (sigma > maxStress) maxStress = sigma;
                        }
                    }
                }
            }

            // Tip deflection (at the last point = L_max)
            const tipDeflection = Y[N - 1];

            // --- Inter-shim analysis ---
            // Compute per-shim moment share and tip reaction forces
            const shimAnalysis = [];
            state.shims.forEach((shim, idx) => {
                const I_i = (state.width * Math.pow(shim.thickness, 3)) / 12;
                const EI_i = state.E * I_i;

                // Find grid index closest to this shim's tip
                const tipIdx = Math.min(N - 1, Math.round(shim.length / ds));

                // Moment carried by this shim at its tip
                const EI_at_tip = EI_arr[tipIdx];
                const M_shim_tip = (EI_i / EI_at_tip) * M[tipIdx];

                // Moment carried by this shim at root
                const EI_at_root = EI_arr[0];
                const M_shim_root = (EI_i / EI_at_root) * M[0];

                // Reaction force at shim tip: the shear this shim carries
                // V_i(s) = (EI_i / EI_total(s)) √ó V_total(s) for uniform curvature sharing
                const V_shim_tip = (EI_i / EI_at_tip) * V[tipIdx];

                // This reaction force is transferred to adjacent shims through contact
                shimAnalysis.push({
                    shimIdx: idx,
                    length: shim.length,
                    thickness: shim.thickness,
                    EI: EI_i,
                    I: I_i,
                    momentAtRoot: M_shim_root,
                    momentAtTip: M_shim_tip,
                    reactionForce: V_shim_tip  // Force transmitted to underlying shim
                });
            });

            // --- Single-shim comparison (longest shim alone) ---
            // Solve again with only the longest shim to show support effect
            const longestShim = state.shims.reduce((a, b) => a.length >= b.length ? a : b, state.shims[0]);
            const I_single = (state.width * Math.pow(longestShim.thickness, 3)) / 12;
            const EI_single = state.E * I_single;
            let singleTipDeflection = 0;
            if (EI_single > 1e-12 && state.load > 0) {
                // Quick analytical estimate for comparison
                singleTipDeflection = (state.load * Math.pow(L_max, 4)) / (8 * EI_single);
            }
            const stackAnalytical = (state.load * Math.pow(L_max, 4)) / (8 * EI_arr[0]);
            const supportFactor = (EI_single > 1e-12 && singleTipDeflection > 1e-12)
                ? (1 - Math.abs(tipDeflection) / singleTipDeflection) * 100
                : 0;

            return {
                S, X, Y, Theta, V, M, maxStress, maxMomentMag, tipDeflection, L_max, N,
                shimAnalysis, singleTipDeflection, stackAnalytical, supportFactor, EI_root: EI_arr[0]
            };
        }

        // ============================================================
        //  LIVE MATH EQUATIONS PANEL
        // ============================================================

        function updateMathPanel(res) {
            const mc = document.getElementById('math-content');
            if (!mc || mc.style.display === 'none') return;
            if (!res) { mc.innerHTML = '<p style="color:#64748b;">Add shims to see calculations.</p>'; return; }

            const E_GPa = state.E / 1000;
            const E_MPa = state.E;
            const b = state.width;
            const w = state.load;
            const L = res.L_max;
            const shims = state.shims;

            // --- 1. Stiffness per shim ---
            let stiffnessRows = '';
            let EI_total = 0;
            shims.forEach((s, idx) => {
                const I_i = (b * Math.pow(s.thickness, 3)) / 12;
                const EI_i = E_MPa * I_i;
                EI_total += EI_i;
                const col = shimColors[idx % shimColors.length];
                stiffnessRows += `<tr>
                    <td><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${col.fill.replace('0.80', '1')};margin-right:6px;"></span>Shim ${idx + 1}</td>
                    <td>${s.length.toFixed(1)}</td>
                    <td>${s.thickness.toFixed(3)}</td>
                    <td>${I_i.toFixed(6)}</td>
                    <td>${EI_i.toFixed(2)}</td>
                </tr>`;
            });

            // --- 2. Analytical results (small deflection, single equivalent beam) ---
            const V_max = w * L;
            const M_max = (w * L * L) / 2;
            const delta_analytical = (w * Math.pow(L, 4)) / (8 * EI_total);
            const t_max = Math.max(...shims.map(s => s.thickness));
            const sigma_max = M_max * (t_max / 2) / (EI_total / E_MPa);

            let html = `
            <!-- Section 1: Input Parameters -->
            <div class="math-section">
                <div class="math-section-title">Input Parameters</div>
                <div class="math-formula">
                    <span class="formula-eq">E = ${E_GPa} GPa = ${E_MPa.toFixed(0)} MPa (N/mm¬≤)</span><br>
                    <span class="formula-eq">b = ${b.toFixed(2)} mm  (width/diameter)</span><br>
                    <span class="formula-eq">w = ${w.toFixed(4)} N/mm  (distributed load)</span><br>
                    <span class="formula-eq">L = ${L.toFixed(2)} mm  (longest shim = beam length)</span>
                </div>
            </div>

            <!-- Section 2: Stiffness -->
            <div class="math-section">
                <div class="math-section-title">Stiffness Calculation (Unbonded Stack)</div>
                <div class="math-formula">
                    <span class="formula-label">Second Moment of Area per shim (unbonded ‚Üí no parallel axis theorem)</span>
                    <span class="formula-eq">I_i = b √ó t_i¬≥ / 12</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Flexural rigidity per shim</span>
                    <span class="formula-eq">EI_i = E √ó I_i</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Total stack stiffness (each shim bends independently)</span>
                    <span class="formula-eq">EI_total = Œ£ EI_i  (sum only shims that cover position s)</span>
                </div>
                <table class="math-shim-table">
                    <thead>
                        <tr><th>Shim</th><th>L (mm)</th><th>t (mm)</th><th>I (mm‚Å¥)</th><th>EI (N¬∑mm¬≤)</th></tr>
                    </thead>
                    <tbody>
                        ${stiffnessRows}
                        <tr class="total-row">
                            <td colspan="4">EI_total (at root, all shims active)</td>
                            <td>${EI_total.toFixed(2)}</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Section 3: Shear Force -->
            <div class="math-section">
                <div class="math-section-title">Shear Force</div>
                <div class="math-formula">
                    <span class="formula-label">Distributed load ‚Üí shear at any position x from root</span>
                    <span class="formula-eq">V(x) = w √ó (L ‚àí x)</span><br>
                    <span class="formula-label">Maximum shear (at root, x = 0)</span>
                    <span class="formula-eq">V_max = w √ó L = ${w.toFixed(4)} √ó ${L.toFixed(2)}</span>
                    <span class="formula-result">V_max = ${V_max.toFixed(4)} N</span>
                </div>
            </div>

            <!-- Section 4: Bending Moment -->
            <div class="math-section">
                <div class="math-section-title">Bending Moment</div>
                <div class="math-formula">
                    <span class="formula-label">Moment at position x (cantilever, fixed at root)</span>
                    <span class="formula-eq">M(x) = ‚àíw √ó (L ‚àí x)¬≤ / 2</span><br>
                    <span class="formula-label">Maximum moment magnitude (at root, x = 0)</span>
                    <span class="formula-eq">|M_max| = w √ó L¬≤ / 2 = ${w.toFixed(4)} √ó ${L.toFixed(2)}¬≤ / 2</span>
                    <span class="formula-result">|M_max| = ${M_max.toFixed(4)} N¬∑mm</span>
                </div>
            </div>

            <!-- Section 5: Deflection -->
            <div class="math-section">
                <div class="math-section-title">Tip Deflection</div>
                <div class="math-formula">
                    <span class="formula-label">Euler-Bernoulli (small deflection, linear analytical solution)</span>
                    <span class="formula-eq">Œ¥_tip = w √ó L‚Å¥ / (8 √ó EI)</span>
                    <span class="formula-eq">     = ${w.toFixed(4)} √ó ${L.toFixed(2)}‚Å¥ / (8 √ó ${EI_total.toFixed(2)})</span>
                    <span class="formula-result">Œ¥_analytical = ${delta_analytical.toFixed(4)} mm</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Arc-length solver (geometrically nonlinear ‚Äî actual result)</span>
                    <span class="formula-eq">Uses numerical integration: dŒ∏/ds = M(s)/EI(s), dx = cos(Œ∏)ds, dy = sin(Œ∏)ds</span>
                    <span class="formula-result">Œ¥_numerical = ${Math.abs(res.tipDeflection).toFixed(4)} mm</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Note: The analytical and numerical values match for small deflections.</span>
                    <span class="formula-label">For large deflections, the arc-length solver is more accurate as it accounts for geometric nonlinearity.</span>
                </div>
            </div>

            <!-- Section 6: Bending Stress -->
            <div class="math-section">
                <div class="math-section-title">Maximum Bending Stress</div>
                <div class="math-formula">
                    <span class="formula-label">Stress at extreme fiber of the thickest shim (t = ${t_max.toFixed(3)} mm)</span>
                    <span class="formula-eq">œÉ = E √ó |Œ∫| √ó (t/2)</span>
                    <span class="formula-eq">  = M_max √ó (t/2) / I_total   (small deflection equivalent)</span>
                    <span class="formula-eq">  = ${M_max.toFixed(4)} √ó (${t_max.toFixed(3)}/2) / ${(EI_total / E_MPa).toFixed(6)}</span>
                    <span class="formula-result">œÉ_max ‚âà ${sigma_max.toFixed(2)} MPa  (analytical)</span>
                    <span class="formula-result">œÉ_max = ${res.maxStress.toFixed(2)} MPa  (from solver)</span>
                </div>
            </div>

            <!-- Section 7: Numerical Method -->
            <div class="math-section">
                <div class="math-section-title">Numerical Method Summary</div>
                <div class="math-formula">
                    <span class="formula-label">Arc-length integration (N = 500 grid points, ds = ${(L / (500 - 1)).toFixed(4)} mm)</span>
                    <span class="formula-eq">1. Shear:  V[i] = V[i+1] + w √ó ds   (backward from free tip)</span>
                    <span class="formula-eq">2. Moment: M[i] = M[i+1] ‚àí ¬Ω(V[i]+V[i+1]) √ó ds  (trapezoidal)</span>
                    <span class="formula-eq">3. Curvature: Œ∫[i] = M[i] / EI[i]</span>
                    <span class="formula-eq">4. Angle: Œ∏[i] = Œ∏[i-1] + ¬Ω(Œ∫[i-1]+Œ∫[i]) √ó ds    (trapezoidal)</span>
                    <span class="formula-eq">5. Position: X[i] = X[i-1] + cos(Œ∏_avg) √ó ds</span>
                    <span class="formula-eq">             Y[i] = Y[i-1] + sin(Œ∏_avg) √ó ds</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Boundary conditions</span>
                    <span class="formula-eq">Fixed root:  Œ∏(0) = 0,  X(0) = 0,  Y(0) = 0</span>
                    <span class="formula-eq">Free tip:    V(L) = 0,  M(L) = 0</span>
                </div>
            </div>`;

            // --- Section 8: Inter-Shim Reaction Forces ---
            if (res.shimAnalysis && state.load > 0) {
                let interRows = '';
                res.shimAnalysis.forEach((sa, idx) => {
                    const col = shimColors[idx % shimColors.length];
                    interRows += `<tr>
                        <td><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${col.fill.replace('0.80', '1')};margin-right:6px;"></span>Shim ${idx + 1}</td>
                        <td>${sa.length.toFixed(1)}</td>
                        <td>${Math.abs(sa.momentAtRoot).toFixed(4)}</td>
                        <td>${((sa.EI / res.EI_root) * 100).toFixed(1)}%</td>
                        <td>${Math.abs(sa.reactionForce).toFixed(4)}</td>
                    </tr>`;
                });

                html += `
            <!-- Section 8: Inter-Shim Reaction Forces -->
            <div class="math-section">
                <div class="math-section-title">Inter-Shim Reaction Forces</div>
                <div class="math-formula">
                    <span class="formula-label">How shims share the load (unbonded contact ‚Äî same curvature)</span>
                    <span class="formula-eq">M_i(s) = (EI_i / EI_total(s)) √ó M(s)</span>
                    <span class="formula-eq">V_i(s) = (EI_i / EI_total(s)) √ó V(s)</span><br>
                    <span class="formula-label">Reaction force at shim tip ‚Äî force transmitted to adjacent shim through contact</span>
                    <span class="formula-eq">R_i = V_i(L_i) = (EI_i / EI_total(L_i)) √ó V(L_i)</span>
                </div>
                <table class="math-shim-table">
                    <thead>
                        <tr><th>Shim</th><th>L (mm)</th><th>|M| at root (N¬∑mm)</th><th>Load share</th><th>Tip reaction (N)</th></tr>
                    </thead>
                    <tbody>
                        ${interRows}
                    </tbody>
                </table>
                <div class="math-formula" style="margin-top:10px;">
                    <span class="formula-label">Physical meaning</span>
                    <span class="formula-eq">Each shim transfers a reaction force at its tip to the shim below (or above).</span>
                    <span class="formula-eq">These contact forces act UPWARD against the applied load ‚Üí reducing deflection.</span>
                    <span class="formula-eq">Shorter shims stiffen the root region, spreading the load resistance.</span>
                </div>
            </div>

            <!-- Section 9: Stack vs Single Shim Comparison -->
            <div class="math-section">
                <div class="math-section-title">Stack Support Effect</div>
                <div class="math-formula">
                    <span class="formula-label">Deflection if ONLY the longest shim (no stack support)</span>
                    <span class="formula-eq">Œ¥_single = w √ó L‚Å¥ / (8 √ó EI_single)</span>
                    <span class="formula-eq">        = ${w.toFixed(4)} √ó ${L.toFixed(2)}‚Å¥ / (8 √ó ${(state.E * (state.width * Math.pow(shims.reduce((a, b) => a.length >= b.length ? a : b).thickness, 3)) / 12).toFixed(2)})</span>
                    <span class="formula-result">Œ¥_single = ${res.singleTipDeflection.toFixed(4)} mm</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Actual deflection WITH full shim stack</span>
                    <span class="formula-result">Œ¥_stack = ${Math.abs(res.tipDeflection).toFixed(4)} mm</span>
                </div>
                <div class="math-formula">
                    <span class="formula-label">Support factor ‚Äî deflection reduction due to inter-shim support</span>
                    <span class="formula-eq">Support = (1 ‚àí Œ¥_stack / Œ¥_single) √ó 100%</span>
                    <span class="formula-result" style="font-size:1.1rem;">Stack reduces deflection by ${res.supportFactor.toFixed(1)}%</span>
                </div>
            </div>`;
            }

            mc.innerHTML = html;
        }


        // ============================================================
        //  RENDERING ‚Äî Main Beam Visualization
        // ============================================================

        function draw() {
            // Solve at current load
            const res = solvePhysics();
            if (!res) return;

            // Solve at max load for stable scaling reference
            const currentLoad = state.load;
            const maxLoadSetting = parseFloat(els.maxLoadInput.value) || 10;
            state.load = maxLoadSetting;
            const resRef = solvePhysics();
            state.load = currentLoad;
            if (!resRef) return;

            // --- Update stat cards ---
            els.maxDef.innerText = Math.abs(res.tipDeflection).toFixed(3) + " mm";
            els.maxStress.innerText = res.maxStress.toFixed(1) + " MPa";
            els.maxStress.style.color = (res.maxStress > 1000) ? "#ef4444" : "white";
            els.forceVal.innerText = state.load.toFixed(2) + " N/mm";
            els.maxMoment.innerText = res.maxMomentMag.toFixed(1) + " N¬∑mm";

            // --- Update live math equations ---
            updateMathPanel(res);

            // ---- MAIN CANVAS ----
            const ctx = ctxs.main;
            const W = ctx.canvas._logicalWidth || ctx.canvas.width;
            const H = ctx.canvas._logicalHeight || ctx.canvas.height;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // Clip to canvas bounds to prevent any drawing outside
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, W, H);
            ctx.clip();

            // --- Scaling ---
            // Use reference (max load) solution for stable scale
            const padL = 70, padR = 40, padT = 50, padB = 40;
            const availW = W - padL - padR;
            const availH = H - padT - padB;

            // Find bounding box from reference solution
            let refMinY = 0, refMaxY = 0;
            for (let i = 0; i < resRef.N; i++) {
                if (resRef.Y[i] < refMinY) refMinY = resRef.Y[i];
                if (resRef.Y[i] > refMaxY) refMaxY = resRef.Y[i];
            }
            // Include shim thickness in bounding box
            const totalThick = state.shims.reduce((a, s) => a + s.thickness, 0);
            refMaxY = Math.max(refMaxY, totalThick + 1);
            refMinY = Math.min(refMinY, -1);

            const rangeY = Math.max(Math.abs(refMinY), Math.abs(refMaxY)) * 2.2;
            const scaleX = availW / (resRef.L_max * 1.05);
            const scaleY = Math.min(scaleX, availH / rangeY);  // Don't stretch Y beyond available space

            const originX = padL;
            const originY = padT + availH * 0.35;  // Anchor near top third

            // --- Draw subtle grid ---
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 1;
            const gridSpacing = chooseGridSpacing(resRef.L_max);
            for (let g = 0; g <= resRef.L_max; g += gridSpacing) {
                const gx = originX + g * scaleX;
                ctx.beginPath();
                ctx.moveTo(gx, padT);
                ctx.lineTo(gx, H - padB);
                ctx.stroke();
            }

            // --- Draw wall (fixed support) ---
            const wallX = originX;
            const wallTop = padT;
            const wallBot = H - padB;
            const wallW = 8;

            // Solid wall
            ctx.fillStyle = '#475569';
            ctx.fillRect(wallX - wallW, wallTop, wallW, wallBot - wallTop);

            // Hatch marks for fixed support
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1.5;
            const hatchSpacing = 8;
            for (let hy = wallTop; hy < wallBot; hy += hatchSpacing) {
                ctx.beginPath();
                ctx.moveTo(wallX - wallW, hy);
                ctx.lineTo(wallX - wallW - 8, hy + 8);
                ctx.stroke();
            }

            // --- Clip beam drawing to the right of the wall ---
            // This prevents the beam from rendering past the y-axis (wall)
            ctx.save();
            ctx.beginPath();
            ctx.rect(originX, 0, W - originX, H);
            ctx.clip();

            // --- Pre-calculate screen points from actual solution ---
            const screenPts = [];
            for (let i = 0; i < res.N; i++) {
                screenPts.push({
                    x: originX + res.X[i] * scaleX,
                    y: originY - res.Y[i] * scaleY  // Invert Y for screen coords
                });
            }

            // --- Compute normals for thickness offset ---
            const normals = [];
            for (let i = 0; i < screenPts.length; i++) {
                let dx, dy;
                if (i === 0) {
                    dx = screenPts[1].x - screenPts[0].x;
                    dy = screenPts[1].y - screenPts[0].y;
                } else if (i === screenPts.length - 1) {
                    dx = screenPts[i].x - screenPts[i - 1].x;
                    dy = screenPts[i].y - screenPts[i - 1].y;
                } else {
                    dx = screenPts[i + 1].x - screenPts[i - 1].x;
                    dy = screenPts[i + 1].y - screenPts[i - 1].y;
                }
                const len = Math.hypot(dx, dy);
                if (len < 1e-9) normals.push({ x: 0, y: -1 });
                else normals.push({ x: dy / len, y: -dx / len });
            }

            // --- Draw load arrows ---
            if (state.load > 0) {
                const arrowCount = Math.min(20, Math.max(5, Math.floor(resRef.L_max / 3)));
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                ctx.lineWidth = 1.5;

                for (let a = 0; a < arrowCount; a++) {
                    const frac = (a + 0.5) / arrowCount;
                    const idx = Math.floor(frac * (res.N - 1));
                    const px = screenPts[idx].x;
                    const py = screenPts[idx].y;
                    const arrowLen = 22;
                    const tipSize = 4;

                    // Arrow shaft (from above the beam, pointing down to beam)
                    const topOffset = totalThick * scaleY + 8;
                    const startY = py - topOffset - arrowLen;
                    const endY = py - topOffset;

                    ctx.beginPath();
                    ctx.moveTo(px, startY);
                    ctx.lineTo(px, endY);
                    ctx.stroke();

                    // Arrowhead
                    ctx.beginPath();
                    ctx.moveTo(px, endY + 2);
                    ctx.lineTo(px - tipSize, endY - tipSize);
                    ctx.lineTo(px + tipSize, endY - tipSize);
                    ctx.closePath();
                    ctx.fill();
                }

                // Load label
                ctx.fillStyle = 'rgba(239, 68, 68, 0.7)';
                ctx.font = '600 11px Inter, sans-serif';
                ctx.textAlign = 'center';
                const midIdx = Math.floor(res.N / 2);
                const topY = screenPts[midIdx].y - totalThick * scaleY - 38;
                ctx.fillText(`w = ${state.load.toFixed(2)} N/mm`, screenPts[midIdx].x, topY);
                ctx.textAlign = 'left';
            }

            // --- Draw shims ---
            let thickOffset = 0;

            state.shims.forEach((shim, idx) => {
                const t = shim.thickness;
                const col = shimColors[idx % shimColors.length];

                ctx.fillStyle = col.fill;
                ctx.strokeStyle = col.stroke;
                ctx.lineWidth = 1.2;
                ctx.beginPath();

                // Top edge (offset = thickOffset + t)
                let lastIdx = 0;
                for (let i = 0; i < res.N; i++) {
                    if (res.S[i] > shim.length) break;
                    lastIdx = i;

                    const offset = (thickOffset + t) * scaleY;
                    const px = screenPts[i].x + normals[i].x * offset;
                    const py = screenPts[i].y + normals[i].y * offset;

                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }

                // Bottom edge (offset = thickOffset) ‚Äî traverse backward
                for (let i = lastIdx; i >= 0; i--) {
                    const offset = thickOffset * scaleY;
                    const px = screenPts[i].x + normals[i].x * offset;
                    const py = screenPts[i].y + normals[i].y * offset;
                    ctx.lineTo(px, py);
                }

                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                thickOffset += t;
            });

            // --- Draw neutral axis (centerline) ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            for (let i = 0; i < res.N; i++) {
                if (i === 0) ctx.moveTo(screenPts[i].x, screenPts[i].y);
                else ctx.lineTo(screenPts[i].x, screenPts[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // --- Dimension annotation ---
            ctx.fillStyle = 'rgba(255,255,255,0.35)';
            ctx.font = '500 10px Inter, sans-serif';
            ctx.fillText(`L_max = ${resRef.L_max.toFixed(1)} mm`, originX + 4, H - 12);

            // Tip deflection annotation
            if (Math.abs(res.tipDeflection) > 0.001) {
                const tipPt = screenPts[screenPts.length - 1];
                ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                ctx.font = '600 11px Inter, sans-serif';
                ctx.fillText(`Œ¥ = ${Math.abs(res.tipDeflection).toFixed(3)} mm`,
                    tipPt.x + 8, tipPt.y + 4);

                // Deflection indicator line
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(tipPt.x, originY);
                ctx.lineTo(tipPt.x, tipPt.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Restore beam clipping (right of wall)
            ctx.restore();
            // Restore canvas bounds clipping
            ctx.restore();

            // --- Auxiliary Graphs ---
            drawGraph(ctxs.disp, res.X, res.Y, "Deflection", "#3b82f6", "x (mm)", "y (mm)");
            drawGraph(ctxs.moment, res.S, res.M, "Moment", "#10b981", "s (mm)", "M (N¬∑mm)");
            drawGraph(ctxs.shear, res.S, res.V, "Shear", "#f59e0b", "s (mm)", "V (N)");
        }


        // ============================================================
        //  AUXILIARY GRAPH RENDERER
        // ============================================================

        function drawGraph(ctx, X, Y, label, color, xLabel, yLabel) {
            const W = ctx.canvas._logicalWidth || ctx.canvas.width;
            const H = ctx.canvas._logicalHeight || ctx.canvas.height;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            const padL = 55, padR = 15, padT = 30, padB = 30;
            const plotW = W - padL - padR;
            const plotH = H - padT - padB;

            if (plotW <= 0 || plotH <= 0) return;

            const minX = 0, maxX = X[X.length - 1] || 1;
            let minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < Y.length; i++) {
                if (Y[i] < minY) minY = Y[i];
                if (Y[i] > maxY) maxY = Y[i];
            }

            // Expand range to include zero
            if (minY > 0) minY = 0;
            if (maxY < 0) maxY = 0;

            // Add 10% padding
            let rY = maxY - minY;
            if (rY < 1e-9) { maxY += 1; minY -= 1; rY = 2; }
            minY -= rY * 0.08;
            maxY += rY * 0.08;
            rY = maxY - minY;

            const rX = maxX - minX || 1;

            const mapX = v => padL + ((v - minX) / rX) * plotW;
            const mapY = v => (padT + plotH) - ((v - minY) / rY) * plotH;

            // --- Grid lines ---
            ctx.font = '500 9px Inter, sans-serif';

            // Y-axis grid
            const yTicks = niceTicksRange(minY, maxY, 5);
            ctx.textAlign = 'right';
            for (const yv of yTicks) {
                const py = mapY(yv);
                if (py < padT - 2 || py > padT + plotH + 2) continue;

                ctx.strokeStyle = (Math.abs(yv) < rY * 0.001) ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.05)';
                ctx.lineWidth = (Math.abs(yv) < rY * 0.001) ? 1.2 : 0.8;
                ctx.beginPath();
                ctx.moveTo(padL, py);
                ctx.lineTo(W - padR, py);
                ctx.stroke();

                ctx.fillStyle = '#64748b';
                ctx.fillText(formatEngineering(yv), padL - 5, py + 3);
            }

            // X-axis grid
            const xTicks = niceTicksRange(minX, maxX, 5);
            ctx.textAlign = 'center';
            for (const xv of xTicks) {
                const px = mapX(xv);
                if (px < padL - 2 || px > W - padR + 2) continue;

                ctx.strokeStyle = 'rgba(255,255,255,0.04)';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(px, padT);
                ctx.lineTo(px, padT + plotH);
                ctx.stroke();

                ctx.fillStyle = '#64748b';
                ctx.fillText(formatEngineering(xv), px, padT + plotH + 14);
            }

            // --- Area fill under curve ---
            const zeroY = mapY(0);
            ctx.fillStyle = color.replace(')', ', 0.08)').replace('rgb', 'rgba');
            // Parse hex color for area fill
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            ctx.fillStyle = `rgba(${r},${g},${b}, 0.08)`;
            ctx.beginPath();
            ctx.moveTo(mapX(X[0]), zeroY);
            for (let i = 0; i < X.length; i++) {
                ctx.lineTo(mapX(X[i]), mapY(Y[i]));
            }
            ctx.lineTo(mapX(X[X.length - 1]), zeroY);
            ctx.closePath();
            ctx.fill();

            // --- Data line ---
            ctx.strokeStyle = color;
            ctx.lineWidth = 2.2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.beginPath();
            for (let i = 0; i < X.length; i++) {
                const px = mapX(X[i]);
                const py = mapY(Y[i]);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // --- Max/min annotation ---
            let absMax = 0, absMaxIdx = 0;
            for (let i = 0; i < Y.length; i++) {
                if (Math.abs(Y[i]) > absMax) { absMax = Math.abs(Y[i]); absMaxIdx = i; }
            }
            if (absMax > 1e-6) {
                const annotX = mapX(X[absMaxIdx]);
                const annotY = mapY(Y[absMaxIdx]);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(annotX, annotY, 3.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '600 9px Inter, sans-serif';
                ctx.textAlign = annotX > W / 2 ? 'right' : 'left';
                const offsetDir = annotX > W / 2 ? -8 : 8;
                ctx.fillText(formatEngineering(Y[absMaxIdx]), annotX + offsetDir, annotY - 8);
            }

            // --- Axis labels ---
            ctx.fillStyle = '#64748b';
            ctx.font = '500 9px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(xLabel, padL + plotW / 2, H - 4);
            // Y label (rotated)
            ctx.save();
            ctx.translate(11, padT + plotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();

            // --- Plot border ---
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            ctx.strokeRect(padL, padT, plotW, plotH);
        }


        // ============================================================
        //  UTILITY FUNCTIONS
        // ============================================================

        /** Choose grid spacing that gives ~5-10 lines */
        function chooseGridSpacing(maxVal) {
            const rough = maxVal / 8;
            const mag = Math.pow(10, Math.floor(Math.log10(rough)));
            const steps = [1, 2, 5, 10];
            for (const s of steps) {
                if (s * mag >= rough) return s * mag;
            }
            return mag * 10;
        }

        /** Generate nice tick values for axis labels */
        function niceTicksRange(min, max, targetCount) {
            const range = max - min;
            if (range <= 0) return [0];

            const roughStep = range / targetCount;
            const mag = Math.pow(10, Math.floor(Math.log10(roughStep)));
            const candidates = [1, 2, 5, 10];
            let step = mag;
            for (const c of candidates) {
                if (c * mag >= roughStep) { step = c * mag; break; }
            }

            // Round to step precision to avoid floating-point drift
            const decimals = Math.max(0, -Math.floor(Math.log10(step)) + 1);
            const ticks = [];
            const start = Math.ceil(min / step) * step;
            for (let v = start; v <= max + step * 0.01; v += step) {
                ticks.push(parseFloat(v.toFixed(decimals)));
            }
            return ticks;
        }

        /** Format numbers with engineering precision */
        function formatEngineering(v) {
            if (Math.abs(v) < 1e-9) return '0';
            const abs = Math.abs(v);
            if (abs >= 1000) return v.toFixed(0);
            if (abs >= 100) return v.toFixed(0);
            if (abs >= 10) return v.toFixed(1);
            if (abs >= 1) return v.toFixed(2);
            if (abs >= 0.1) return v.toFixed(3);
            return v.toPrecision(3);
        }


        // ============================================================
        //  STATE MANAGEMENT & UI
        // ============================================================

        function updateState() {
            state.E = Math.max(0, parseFloat(els.eMod.value) || 0) * 1000;  // GPa ‚Üí MPa
            state.width = Math.max(0.01, parseFloat(els.width.value) || 0.01);
            const maxL = Math.max(0, parseFloat(els.maxLoadInput.value) || 0);
            const pct = parseFloat(els.slider.value) || 0;
            state.load = Math.max(0, (pct / 100) * maxL);
            draw();
        }

        function renderShimList() {
            els.shimList.innerHTML = '';
            state.shims.forEach((shim, idx) => {
                const col = shimColors[idx % shimColors.length];
                const item = document.createElement('div');
                item.className = 'shim-item';
                item.innerHTML = `
                    <div>
                        <label><span class="color-dot" style="background:${col.fill.replace('0.80', '1')}"></span>Length (mm)</label>
                        <input type="number" value="${shim.length}" step="1" min="0.1"
                            onchange="updateShim(${idx}, 'length', this.value)">
                    </div>
                    <div>
                        <label>Thickness (mm)</label>
                        <input type="number" value="${shim.thickness}" step="0.05" min="0.01"
                            onchange="updateShim(${idx}, 'thickness', this.value)">
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="removeShim(${idx})">‚úï</button>
                `;
                els.shimList.appendChild(item);
            });
        }

        window.updateShim = (i, k, v) => {
            const val = parseFloat(v) || 0;
            state.shims[i][k] = Math.max(0.001, val);  // Clamp to positive
            updateState();
        };
        window.removeShim = (i) => { state.shims.splice(i, 1); renderShimList(); updateState(); };

        els.eMod.oninput = updateState;
        els.width.oninput = updateState;
        els.maxLoadInput.onchange = updateState;
        els.slider.oninput = updateState;
        els.addShimBtn.onclick = () => {
            state.shims.push({ length: 30, thickness: 0.2 });
            renderShimList();
            updateState();
        };
        els.sortShimBtn.onclick = () => {
            state.shims.sort((a, b) => b.length - a.length);
            renderShimList();
            updateState();
        };

        // Math panel collapse toggle
        document.getElementById('toggle-math-btn').onclick = () => {
            const mc = document.getElementById('math-content');
            const btn = document.getElementById('toggle-math-btn');
            if (mc.style.display === 'none') {
                mc.style.display = '';
                btn.textContent = 'Collapse';
                draw(); // Re-render to populate panel
            } else {
                mc.style.display = 'none';
                btn.textContent = 'Expand';
            }
        };


        // ============================================================
        //  SHARING
        // ============================================================

        els.shareBtn.onclick = () => {
            const data = {
                s: state.shims, ps: { E: state.E, w: state.width, mx: els.maxLoadInput.value }
            };
            const b64 = btoa(JSON.stringify(data));
            const url = window.location.href.split('#')[0] + '#' + b64;
            navigator.clipboard.writeText(url).then(() => {
                const old = els.shareBtn.innerText;
                els.shareBtn.innerText = "‚úì Copied!";
                setTimeout(() => els.shareBtn.innerText = old, 1500);
            });
        };

        function loadFromUrl() {
            if (window.location.hash) {
                try {
                    const data = JSON.parse(atob(window.location.hash.substring(1)));
                    if (data.s) state.shims = data.s;
                    if (data.ps) {
                        state.E = parseFloat(data.ps.E);
                        state.width = parseFloat(data.ps.w);
                        els.maxLoadInput.value = data.ps.mx;
                    }
                    els.eMod.value = state.E / 1000;
                    els.width.value = state.width;
                    renderShimList();
                } catch (e) { console.log(e); }
            }
        }


        // ============================================================
        //  INITIALIZATION
        // ============================================================

        function resizeCanvases() {
            Object.values(els.canvases).forEach(c => {
                const r = c.parentElement.getBoundingClientRect();
                // Use devicePixelRatio for crisp rendering
                const dpr = window.devicePixelRatio || 1;
                c.width = r.width * dpr;
                c.height = r.height * dpr;
                c.style.width = r.width + 'px';
                c.style.height = r.height + 'px';
                c.getContext('2d').scale(dpr, dpr);
                // Store logical size for drawing
                c._logicalWidth = r.width;
                c._logicalHeight = r.height;
            });
            draw();
        }

        // Override canvas width/height getters for logical coordinates
        const origCtxGetter = Object.getOwnPropertyDescriptor(HTMLCanvasElement.prototype, 'width');

        // Patch draw functions to use logical dimensions
        const origGetContext = HTMLCanvasElement.prototype.getContext;

        window.onresize = resizeCanvases;

        loadFromUrl();
        state.shims.sort((a, b) => b.length - a.length);  // Longest shim on top
        renderShimList();
        setTimeout(resizeCanvases, 100);
    </script>
</body>

</html>